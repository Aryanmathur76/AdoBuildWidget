<script lang="ts">
  import * as Popover from "$lib/components/ui/popover/index.js";
  // import * as HoverCard from "$lib/components/ui/hover-card/index.js";
  import {
    getPipelineBadgeColor,
    getTestPassColor,
    getTestFailColor,
    getTestNoDataColor,
    getTestInProgressColor,
  } from "$lib/constants/colors.js";
  import { getTestQuality, PIPELINE_TEST_THRESHOLDS } from "$lib/constants/thresholds.js";
  import { Skeleton } from "$lib/components/ui/skeleton/index.js";
  import { goto } from "$app/navigation";
  import { env } from "$env/dynamic/public";
  import { pipelineDataService } from "$lib/stores/pipelineDataService.js";

  // Helper function to get bar color based on pass rate
  function getBarColor(passRate: number): string {
    const quality = getTestQuality(passRate);
    switch (quality) {
      case 'good':
        return getTestPassColor();
      case 'ok':
        return 'bg-yellow-500'; // Use yellow for ok quality
      case 'bad':
        return getTestFailColor();
      default:
        return getTestNoDataColor();
    }
  }

  let { dayObj, delay = 0, viewMode = "simple" }: { dayObj: any; delay?: number; viewMode?: "simple" | "graph" } = $props();

  let showPopover = $state(false);
  let pipelineData = $state<Array<{
    id: string;
    name: string;
    type: string;
    status: string;
    passCount: number;
    failCount: number;
  }>>([]);
  let loadingPipelines = $state(false);
  let hoverTimeout: ReturnType<typeof setTimeout> | null = $state(null);

  // Get pipeline configuration
  let pipelineConfig: any = null;
  try {
    if (env.PUBLIC_AZURE_PIPELINE_CONFIG) {
      pipelineConfig = JSON.parse(env.PUBLIC_AZURE_PIPELINE_CONFIG);
    }
  } catch (e) {
    console.warn("Failed to parse pipeline config:", e);
  }

  // Fetch individual pipeline data on mount with delay
  $effect(() => {
    if (dayObj && !dayObj.disabled && dayObj.quality !== "unknown") {
      // Stagger loading to prevent overwhelming the API
      setTimeout(() => {
        fetchPipelineData();
      }, delay);
    }
  });

  // Fetch individual pipeline data
  async function fetchPipelineData() {
    if (
      !pipelineConfig?.pipelines ||
      loadingPipelines ||
      pipelineData.length > 0 // Prevent refetching if we already have data
    )
      return;

    loadingPipelines = true;
    
    // Add a timeout to prevent hanging
    const timeoutId = setTimeout(() => {
      console.warn(`Pipeline data fetch timed out for ${dayObj.dateStr}`);
      loadingPipelines = false;
    }, 10000); // 10 second timeout

    const results: Array<{
      id: string;
      name: string;
      type: string;
      status: string;
      passCount: number;
      failCount: number;
    }> = [];

    try {
      for (const pipeline of pipelineConfig.pipelines) {
        if (pipeline.type === "build") {
          // Use the silent method to avoid console errors for missing data
          const data = await pipelineDataService.fetchBuildDataSilent(
            dayObj.dateStr,
            pipeline.id,
          );
          if (data) {
            // Build API might return array of builds
            if (Array.isArray(data)) {
              data.forEach((build: any, index: number) => {
                results.push({
                  id: `${pipeline.id}-${index}`,
                  name:
                    build.name ||
                    build.testRunName ||
                    pipeline.displayName ||
                    `Build ${pipeline.id}`,
                  type: "build",
                  status: build.status || "unknown",
                  passCount: build.passedTestCount || 0,
                  failCount: build.failedTestCount || 0,
                });
              });
            } else {
              results.push({
                id: pipeline.id,
                name: pipeline.displayName,
                type: "build",
                status: data.status || "unknown",
                passCount: data.passedTestCount || 0,
                failCount: data.failedTestCount || 0,
              });
            }
          } else {
            // No build data found for this date - show placeholder
            results.push({
              id: pipeline.id,
              name: pipeline.displayName,
              type: "build",
              status: "no-data",
              passCount: 0,
              failCount: 0,
            });
          }
        } else if (pipeline.type === "release") {
          // Use the silent method to avoid console errors for missing data
          const data = await pipelineDataService.fetchReleaseDataSilent(
            dayObj.dateStr,
            pipeline.id,
          );
          if (data) {
            results.push({
              id: pipeline.id,
              name: pipeline.displayName,
              type: "release",
              status: data.status || "unknown",
              passCount: data.passedTestCount || 0,
              failCount: data.failedTestCount || 0,
            });
          } else {
            // No release data found for this date - show placeholder
            results.push({
              id: pipeline.id,
              name: pipeline.displayName,
              type: "release",
              status: "no-data",
              passCount: 0,
              failCount: 0,
            });
          }
        }
      }
    } catch (error) {
      console.error("Error fetching pipeline data:", error);
    } finally {
      clearTimeout(timeoutId);
    }

    pipelineData = results;
    loadingPipelines = false;
  }

  // Handle popover open with delay
  function handlePopoverOpen() {
    // Clear any existing timeout
    if (hoverTimeout) {
      clearTimeout(hoverTimeout);
    }
    
    // Set a timeout to show popover after 300ms
    hoverTimeout = setTimeout(() => {
      showPopover = true;
    }, 300);
  }

  // Reset popover when closes
  function handlePopoverClose() {
    // Clear the timeout if user moves away before 300ms
    if (hoverTimeout) {
      clearTimeout(hoverTimeout);
      hoverTimeout = null;
    }
    
    showPopover = false;
  }
</script>

{#if dayObj}
  <Popover.Root bind:open={showPopover}>
    <Popover.Trigger
      class={`w-full h-full min-w-0 min-h-0 cursor-pointer ${dayObj.animationClass} hover:scale-110 hover:shadow-xl hover:z-10`}
      style="aspect-ratio: 1 / 1; transition: all 0.2s ease-in-out; position: relative; border: none; padding: 1px; display: flex; align-items: end; justify-content: space-between; font-weight: bold; border-radius: 12px;"
      aria-label={`Go to build ${dayObj.dateStr}`}
      onclick={() => goto(`/build/${dayObj.dateStr}`)}
      onmouseenter={handlePopoverOpen}
      onmouseleave={handlePopoverClose}
      disabled={dayObj.disabled}
    >
      {#if viewMode === "simple"}
        <div class="flex items-center justify-center w-full h-full {dayObj.colorClass} rounded-sm">
          {#if dayObj.disabled}
            <span class="material-symbols-outlined text-white" style="font-size: 1.25em;">schedule</span>
          {:else}
            <span class="text-xs font-bold">{dayObj.day}</span>
          {/if}
        </div>
      {:else if loadingPipelines}
        <div class="flex flex-col h-full w-full bg-neutral-900 rounded-sm">
          <!-- Banner with date and quality color (top 20%) -->
          <div class="h-1/4 w-full flex items-center justify-center {dayObj.colorClass} rounded-t-sm border-b border-white/20">
            <span class="text-xs font-bold drop-shadow-sm">
              {#if dayObj.disabled}
                <span class="material-symbols-outlined" style="font-size: 0.75em;">schedule</span>
              {:else}
                {dayObj.day}
              {/if}
            </span>
          </div>
          <!-- Graph content (bottom 80%) -->
          <div class="h-3/4 flex items-end justify-between w-full gap-0.5 px-1 pt-1">
            {#each Array(5) as _, i}
              <div class="flex-1 bg-gray-300 animate-pulse rounded-sm" style="height: {20 + Math.random() * 60}%"></div>
            {/each}
          </div>
        </div>
      {:else if pipelineData.length > 0}
        <div class="flex flex-col h-full w-full bg-neutral-900 rounded-sm">
          <!-- Banner with date and quality color (top 20%) -->
          <div class="h-1/4 w-full flex items-center justify-center {dayObj.colorClass} rounded-t-sm border-b border-white/20">
            <span class="text-xs font-bold drop-shadow-sm">
              {#if dayObj.disabled}
                <span class="material-symbols-outlined" style="font-size: 0.75em;">schedule</span>
              {:else}
                {dayObj.day}
              {/if}
            </span>
          </div>
          <!-- Graph content (bottom 80%) -->
          <div class="h-3/4 flex items-end justify-center w-full h-full gap-0.5 px-1 pt-1">
            {#each pipelineData as pipeline (pipeline.id)}
              {@const totalTests = pipeline.passCount + pipeline.failCount}
              {@const passRate = totalTests > 0 ? (pipeline.passCount / totalTests) * 100 : 0}
              {@const barHeight = totalTests > 0 ? Math.max(10, (passRate / 100) * 80) : 10}
              {@const barColor = getBarColor(passRate)}
              <div 
                class="flex-1 {barColor} rounded-sm transition-all duration-200 max-w-4" 
                style="height: {barHeight}%; min-width: 3px;"
              ></div>
            {/each}
          </div>
        </div>
      {:else}
        <div class="flex flex-col h-full w-full bg-neutral-900 rounded-sm">
          <!-- Banner with date and quality color (top 20%) -->
          <div class="h-1/4 w-full flex items-center justify-center {dayObj.colorClass} rounded-t-sm">
            <span class="text-xs font-bold drop-shadow-sm">
              {dayObj.day}
            </span>
          </div>
          <!-- Simple content (bottom 80%) -->
          <div class="h-3/4 flex items-center justify-center w-full">
            <span class="text-xs font-bold">
              {#if dayObj.disabled}
                <span class="material-symbols-outlined" style="font-size: 1em;">schedule</span>
              {:else}
                {dayObj.day}
              {/if}
            </span>
          </div>
        </div>
      {/if}
    </Popover.Trigger>

    <Popover.Content class="w-80 p-2">
      <div class="space-y-3">
        {#if loadingPipelines}
          <div class="space-y-2">
            <Skeleton class="h-6 w-full" />
            <Skeleton class="h-6 w-full" />
            <Skeleton class="h-6 w-full" />
          </div>
        {:else if pipelineData.length > 0}
          <link
            href="https://fonts.googleapis.com/icon?family=Material+Icons|Material+Icons+Outlined"
            rel="stylesheet"
          />
          <div class="space-y-1">
            {#each pipelineData as pipeline (pipeline.id)}
              <div class="flex items-center justify-between gap-2 py-1">
                <div class="flex-shrink-0">
                  <span
                    class="inline-block text-xs px-2 py-0.5 rounded {getPipelineBadgeColor(
                      pipeline.status,
                    )}"
                  >
                    {pipeline.name}
                  </span>
                </div>
                <div class="flex items-center gap-1.5 flex-shrink-0">
                  <div
                    class="w-40 h-4 bg-zinc-200 rounded overflow-hidden relative"
                  >
                    {#if pipeline.passCount + pipeline.failCount > 0}
                      {@const totalTests =
                        pipeline.passCount + pipeline.failCount}
                      {@const passPercentage =
                        (pipeline.passCount / totalTests) * 100}
                      <div class="h-full flex">
                        <div
                          class={getTestPassColor()}
                          style="width: {passPercentage}%"
                        ></div>
                        <div
                          class={getTestFailColor()}
                          style="width: {100 - passPercentage}%"
                        ></div>
                      </div>
                      <div
                        class="absolute inset-0 flex items-center justify-center"
                      >
                        <span class="text-xs text-white drop-shadow-md">
                          Pass: {pipeline.passCount} Fail: {pipeline.failCount}
                        </span>
                      </div>
                    {:else}
                      <div
                        class="h-full w-full flex items-center justify-center {pipeline.status === 'inProgress' ? getTestInProgressColor() : getTestNoDataColor()}"
                      >
                        {#if pipeline.status === "inProgress"}
                          <span class="text-xs text-white">In Progress</span>
                        {:else}
                          <span class="text-xs text-white">No Tests</span>
                        {/if}
                      </div>
                    {/if}
                  </div>
                </div>
              </div>
            {/each}
          </div>
          {#if dayObj.totalPassCount !== undefined || dayObj.totalFailCount !== undefined}
            <div class="border-t pt-1">
              <p class="text-xs text-muted-foreground">
                Total Tests: {(dayObj.totalPassCount || 0) +
                  (dayObj.totalFailCount || 0)}
                (Pass: {dayObj.totalPassCount || 0}, Fail: {dayObj.totalFailCount ||
                  0})
              </p>
            </div>
          {/if}
        {:else if dayObj.disabled}
          <p class="text-sm text-muted-foreground">
            Future date - no data available
          </p>
        {:else if dayObj.quality === "unknown"}
          <p class="text-sm text-muted-foreground">
            No pipeline data available for this date
          </p>
        {:else}
          <p class="text-sm text-muted-foreground">
            No pipeline configuration found
          </p>
        {/if}
      </div>
    </Popover.Content>
  </Popover.Root>
{/if}
